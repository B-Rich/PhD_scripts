#!/usr/bin/env python
# -*- coding: utf-8 -*-

import math, sys
import numpy as np
import ReadWrite as rw

# Smooth coordination number function
def Cn_Zn(dist,c,x1,x2):
  def Cn_func(x,c,x1,x2):
    def f(x,c,a):
      return (1-np.tanh(a*(x-c)))/2
    alpha = 1
    while (f(x1,c,alpha)<0.999 and f(x2,c,alpha)>0.001):
      alpha=alpha*2
    return f(x,c,alpha)
  return sum([Cn_func(dist[i],c,x1,x2) for i in range(5)])

# Find out how many configurations are stored
nconf = rw.nconfFromDist(sys.argv[1]+".dist")
print "#### Simulation", sys.argv[1].split("/")[-1], "####"
print "Reading ", nconf, "configurations"

# Read the distances in
trajDist = rw.readFromDistanceFile(sys.argv[1] + ".dist", nconf)

# Read the correspondence between pairs and atoms in Pairs.dat
pairs = {} # dict with [Atom1(N), Atom2(Zn)] at key pair 1-2
nitropairs = {} # dict with [[First Pair number, Atom2(Zn)], [Second Pair number, Atom2(Zn)], [...], [Last Pair number, Atom2(Zn)]] at key Atom1(N)
tmp = 0
with open(sys.argv[2],"r") as pfile:
  next(pfile)
  for line in pfile:
    sp = line.split()
    pairs[int(sp[2])-1] = [int(sp[0]),int(sp[1])]
    if (int(sp[1]) not in nitropairs):
      if (len(nitropairs) == 0): origin = int(sp[1])
      nitropairs[int(sp[1])] = [[int(sp[2])-1,int(sp[0])]]
    elif (int(sp[1]) in nitropairs):
      nitropairs[int(sp[1])].append([int(sp[2])-1,int(sp[0])])
    tmp = int(sp[1])

npairs = len(trajDist)

Nitro = {}
Zinc = {}

c1 = 0
c2 = 0
for i in range(len(pairs)):
  if (pairs[i][0] not in Nitro):
    Nitro[pairs[i][0]] = c1
    c1 = c1 + 1

for i in range(len(pairs)):
  if (pairs[i][1] not in Zinc):
    Zinc[pairs[i][1]] = c2
    c2 = c2 + 1

rnitropairs=range(len(nitropairs[origin]))

distances = [0.0 for j in rnitropairs]
distances40 = [0.0 for j in rnitropairs]
coord_index = -10
second_index = -10
tmp1 = 200
tmp2 = 200
nitro_active={}
Cnumbers={}
cutoff = float(sys.argv[-1])
x1 = float(sys.argv[-3])
x2 = float(sys.argv[-2])
nconf = nconf/10
for key in nitropairs:
  Cnumbers[key] = [0.0 for x in range(nconf)]
  i = key
  coord_index = -10
  second_index = -10
  third_index = -10
  fourth_index = -10
  tmp1 = 2000
  tmp2 = 2000
  tmp3 = 2000
  tmp4 = 2000
  tmplist = [tmp1,tmp2,tmp3,tmp4]
  for time in range(0,nconf/25):
    for n in rnitropairs:
      #print i, n, time, len(nitropairs), len(nitropairs[i]), len(trajDist)
      #print nitropairs[i][n][0]
      d = trajDist[nitropairs[i][n][0]][time]
      distances[n] = d
    sortdist = sorted(distances)
    Cnumbers[i][time] = Cn_Zn(sortdist,cutoff,x1,x2)
  for time in range(1+23*nconf/25,nconf):
    for n in rnitropairs:
      d = trajDist[nitropairs[i][n][0]][time]
      distances[n] = d
    sortdist = sorted(distances)
    Cnumbers[i][time] = Cn_Zn(sortdist,cutoff,x1,x2)
  for time in range(nconf/25,1+23*nconf/25):
    for n in rnitropairs:
      distances[n] = trajDist[nitropairs[i][n][0]][time]
      distances40[n] = [trajDist[nitropairs[i][n][0]][time+dt] for dt in range(30,100,2)]
    sortdist = sorted(distances)
    Cnumbers[i][time] = Cn_Zn(sortdist,cutoff,x1,x2)
    if (sortdist[0]<=cutoff and distances40[distances.index(sortdist[0])]<=cutoff):
      fst_neighb = distances.index(sortdist[0])
      scd_neighb = distances.index(sortdist[1])
      thi_neighb = distances.index(sortdist[2])
      fou_neighb = distances.index(sortdist[3])
      neighbs = [fst_neighb,scd_neighb,thi_neighb,fou_neighb]
      if (coord_index == -10):
        coord_index = fst_neighb
        second_index = scd_neighb
        third_index = thi_neighb
        fourth_index = fou_neighb
        nitro_active[i] = [[coord_index, time, nitropairs[i][coord_index][0]]]
      elif (any(neighbs) not in tmplist and (distances[nitro_active[i][-1][0]] > cutoff) and (distances40[nitro_active[i][-1][0]] > x2)):
        coord_index = fst_neighb
        if (sortdist[1]<=cutoff and distances40[scd_neighb]<=cutoff):
          second_index = scd_neighb
          if (sortdist[2]<=cutoff and distances40[thi_neighb]<=cutoff):
            third_index = thi_neighb
            if (sortdist[3]<=cutoff and distances40[fou_neighb]<=cutoff):
              fourth_index = fou_neighb
            else:
              fourth_index = third_index
          else:
            third_index = second_index
            fourth_index = second_index
        else:
          second_index = coord_index
          third_index = coord_index
          fourth_index = coord_index
        indexlist = [nitro_active[i][-1][0]]
        if (len(nitro_active[i])>1): indexlist.append(nitro_active[i][-2][0])
        if (len(nitro_active[i])>2): indexlist.append(nitro_active[i][-3][0])
        if (len(nitro_active[i])>3): indexlist.append(nitro_active[i][-4][0])
        timelist = nitro_active[i][-1][1]
        if (coord_index not in indexlist and time>timelist+40):
          nitro_active[i].append([coord_index, time, nitropairs[i][coord_index][0]])
        elif (coord_index in indexlist and second_index not in indexlist and time>timelist+40):
          nitro_active[i].append([second_index, time, nitropairs[i][second_index][0]])
        elif (coord_index in indexlist and second_index in indexlist and third_index not in indexlist and time>timelist+40):
          nitro_active[i].append([third_index, time, nitropairs[i][third_index][0]])
        elif (coord_index in indexlist and second_index in indexlist and third_index in indexlist and fourth_index not in indexlist and time>timelist+40):
          nitro_active[i].append([fourth_index, time, nitropairs[i][fourth_index][0]])
      tmp1 = coord_index
      tmp2 = second_index
      tmp3 = third_index
      tmp4 = fourth_index
      tmplist = [tmp1,tmp2,tmp3,tmp4]
  if (i not in nitro_active):
    nitro_active[i] = [[]]



Cnumber = [0.0 for i in range(nconf)]
for i in nitropairs:
  for t in range(nconf):
    Cnumber[t]=Cnumber[t]+Cnumbers[i][t]/len(nitropairs)
with open(sys.argv[1]+".CN","w") as fout:
  for k in range(nconf):
    fout.write(str(k*5)+" "+str(Cnumber[k])+" "+str(Cnumbers[i][k])+"\n")

pairs_numb = 0
pairs_numb2 = 0
for i in nitropairs:
  if (len(nitro_active[i])>1):
    pairs_numb = pairs_numb + len(nitro_active[i])-1
    pairs_numb2 = pairs_numb2 + len(nitro_active[i])-1
  elif (len(nitro_active[i])<=1):
    pairs_numb = pairs_numb + len(nitro_active[i])

uglob = 0
mindelay = 1e15
maxdelay = 0.0
d1 = [[0.0 for x in range(2*nconf)] for y in range(pairs_numb2)]
d2 = [[0.0 for x in range(2*nconf)] for y in range(pairs_numb2)]
Cn = [[0.0 for x in range(2*nconf)] for y in range(pairs_numb2)]
offset=50
for i in nitropairs:
#  print "Zinc number", i
  nuldelay = 0
  u = 0
  offset=50
  if (len(nitro_active[i]) >= 2):
    mindelays = list()
    delays = [int(0) for p in range(len(nitro_active[i])-1)]
    l = 0
    while(l<len(delays)):
      diff = 100
      n = [nitro_active[i][u+p][0] for p in range(len(nitro_active[i]))]
      times = [nitro_active[i][u+p][1] for p in range(len(nitro_active[i]))]
      for k in range(times[l],times[l+1]):
        d = [trajDist[nitropairs[i][z][0]][k] for z in n]
        dm100 = [trajDist[nitropairs[i][z][0]][k-offset] for z in n]
        if (k+offset<nconf): d100 = [trajDist[nitropairs[i][z][0]][k+offset] for z in n]
        if (k+offset>=nconf): d100 = [trajDist[nitropairs[i][z][0]][nconf-1] for z in n]
        dm = [[trajDist[nitropairs[i][z][0]][x] for x in range(k-offset-10,k-offset)] for z in n]
        if (k+offset+10<nconf): dp = [[trajDist[nitropairs[i][z][0]][x] for x in range(k+offset,k+offset+10)] for z in n]
        if (k+offset+10>=nconf): dp = [[trajDist[nitropairs[i][z][0]][x] for x in range(nconf-10,nconf)] for z in n]
        if (abs(d[l]-d[l+1])<=diff and d100[l]>=d100[l+1] and dm100[l]<=dm100[l+1] and min(dm[l+1])>cutoff+0.55 and max(dm[l])<cutoff+0.45 and max(dp[l+1])<cutoff+0.45 and min(dp[l])>cutoff+0.55):
          diff = abs(d[l]-d[l+1])
          delays[l] = int(k)
      if delays[l]==0:
        nuldelay = nuldelay+1
        #delays[l] = times[l+1]-(nconf/50)
        #if (delays[l]<(nconf/10)): delays[l]=nconf/50
        delays.remove(delays[l])
        times.remove(times[l+1])
        nitro_active[i].remove(nitro_active[i][l+1])
        if (offset<80): offset = offset + 10
        l = l - 1
        #print nuldelay, delays, nitro_active[i]
      l = l + 1
    for l in range(len(delays)):
      for k in range(nconf-delays[l],2*nconf-delays[l]):
        k2 = k + delays[l] - nconf
        d = [trajDist[nitropairs[i][z][0]][k2] for z in n]
        d1[uglob+l][k] = d[l]
        d2[uglob+l][k] = d[l+1]
        Cn[uglob+l][k] = Cnumbers[i][k2]
    if (len(delays)>0):
      if(min(delays)<mindelay): mindelay = min(delays)
      if(max(delays)>maxdelay): maxdelay = max(delays)
    uglob = uglob + len(delays)

offset=50
print "Number of exchange trajectories averaged:", uglob
print "Maximum time before t0", mindelay*5, "fs"
print "Maximum time after t0", (nconf-maxdelay)*5, "fs"
ndist = uglob
d1_tot = [0.0 for x in range(mindelay+nconf-maxdelay)]
sigma1 = [0.0 for x in range(mindelay+nconf-maxdelay)]
median1 = [0.0 for x in range(mindelay+nconf-maxdelay)]
d2_tot = [0.0 for x in range(mindelay+nconf-maxdelay)]
sigma2 = [0.0 for x in range(mindelay+nconf-maxdelay)]
median2 = [0.0 for x in range(mindelay+nconf-maxdelay)]
Cn_tot = [0.0 for x in range(mindelay+nconf-maxdelay)]
Cn_med = [0.0 for x in range(mindelay+nconf-maxdelay)]
for k in range(nconf-mindelay,2*nconf-maxdelay):
  k2 = k - nconf + mindelay
  for d in range(ndist):
    d1_tot[k2] = d1_tot[k2] + d1[d][k]/ndist
    d2_tot[k2] = d2_tot[k2] + d2[d][k]/ndist
    Cn_tot[k2] = Cn_tot[k2] + Cn[d][k]/ndist
  for d in range(ndist):
    sigma1[k2] = sigma1[k2] + ((d1[d][k]-d1_tot[k2])**2)/(ndist-1)
    sigma2[k2] = sigma2[k2] + ((d2[d][k]-d2_tot[k2])**2)/(ndist-1)
  sigma1[k2] = math.sqrt(sigma1[k2])
  sigma2[k2] = math.sqrt(sigma2[k2])
  dist1 = sorted([d1[d][k] for d in range(ndist)])
  dist2 = sorted([d2[d][k] for d in range(ndist)])
  SCn = sorted([Cn[d][k] for d in range(ndist)])
  if (ndist%2==0):
    median1[k2] = float((dist1[ndist/2]+dist1[2+ndist/2])/2)
    median2[k2] = float((dist2[ndist/2]+dist2[2+ndist/2])/2)
    Cn_med[k2] = float((SCn[ndist/2]+SCn[2+ndist/2])/2)
  elif ((ndist+1)%2==0):
    median1[k2] = float(dist1[1+ndist/2])
    median2[k2] = float(dist2[1+ndist/2])
    Cn_med[k2] = float(SCn[1+ndist/2])

with open(sys.argv[1]+".avgtraj","w") as fout:
  for k in range(nconf-mindelay,2*nconf-maxdelay):
    k2 = k - nconf + mindelay
    fout.write(str((k-nconf)*5)+" "+str(d1_tot[k2])+" "+str(d2_tot[k2])+" "+str(median1[k2])+" "+str(median2[k2])+" "+str(sigma1[k2])+" "+str(sigma2[k2])+"\n")
with open(sys.argv[1]+".CNtraj","w") as fout:
  for k in range(nconf-mindelay,2*nconf-maxdelay):
    k2 = k - nconf + mindelay
    fout.write(str((k-nconf)*5)+" "+str(Cn_tot[k2])+" "+str(Cn_med[k2])+"\n")

d1_all = []
d2_all = []
Cn_all = []
time = []
for d in range(ndist):
  for k in range(nconf-mindelay,2*nconf-maxdelay):
    k2 = k - nconf + mindelay
    d1_all.append(d1[d][k])
    Cn_all.append(Cn[d][k])
    d2_all.append(d2[d][k])
    time.append((k-nconf)*5)


count=0
with open((sys.argv[1].split("/"))[-1]+".alldist","w") as fout:
  for d in range(ndist):
    for k in range(nconf-mindelay,2*nconf-maxdelay):
      fout.write(str(time[count])+" "+str(d1_all[count])+" "+str(d2_all[count])+"\n")
      count=count+1

print "############################################################\n\n"
